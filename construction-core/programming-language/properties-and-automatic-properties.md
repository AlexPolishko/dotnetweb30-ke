# Properties and automatic properties

Properties are just a simplification for “real” accessor and mutator methods. Although you can encapsulate a piece of field data using traditional get and set methods, .NET languages prefer to enforce data encapsulation state data using properties. 

A C\# property is composed by defining a _**get**_ scope \(_**accessor**_\) and _**set**_ scope \(_**mutator**_\) directly within the property itself. Property specifies the type of data it is encapsulating by what appears to be a return value. Unlike a method, properties do not make use of parentheses \(not even empty parentheses\) when being defined. 

```csharp
public int ID
{
    get { return empID; }
    set { empID = value; }
}
```

Within a **set** scope of a property, you use a token named **value**, which is used to represent the incoming value used to assign the property by the caller. This token is _not_ a true C\# keyword but is what is known as a _**contextual keyword**_. When the token value is within the set scope of the property, it always represents the value being assigned by the caller, and it will always be the same underlying data type as the property itself.

Properties \(as opposed to accessor and mutator methods\) also make your types easier to manipulate, in that properties are able to respond to the intrinsic operators of C\#.

Properties, specifically the set portion of a property, are common places to package up the business rules of your class. Beyond updating constructors to use properties when assigning values, it is good practice to use properties throughout a class implementation to ensure your business rules are always enforced. In many cases, the only time when you directly make reference to the underlying private piece of data is within the property itself.

#### Read-Only and Write-Only Properties

When encapsulating data, you might want to configure a _read-only property_. To do so, simply omit the **set** block. Likewise, if you want to have a _write-only property_, omit the **get** block.

```csharp
public string SocialSecurityNumber
{
    get { return empSSN; }
}
```

#### Static Properties

You can formalize static properties

```csharp
// A static point of data.
private static double currInterestRate = 0.04;

// A static property.
public static double InterestRate
{
    get { return currInterestRate; }
    set { currInterestRate = value; }
}
```

#### Automatic Properties

In some cases you may not need any implementation logic beyond simply getting and setting the value. To streamline the process of providing simple encapsulation of field data, you may use _automatic property syntax_. This feature will offload the work of defining a private backing field and the related C\# property member to the compiler using a new bit of syntax.

```csharp
public string PetName { get; set; }
```

When defining automatic properties, you simply specify the access modifier, underlying data type, property name, and empty get/set scopes. At compile time, your type will be provided with an autogenerated private backing field and a fitting implementation of the get/set logic.

With the current version of C\#, it is now possible to define a “read-only automatic property” by omitting the set scope. However, it is not possible to define a write-only property.

```csharp
// Read-only property? This is OK!
public int MyReadOnlyProp { get; }

// Write only property? Error!
public int MyWriteOnlyProp { set; }
```

Initialization of Automatic Properties:

```csharp
// The hidden backing field is set to 1.
public int NumberOfCars { get; set; } = 1;
```

